## 템플릿 메서드 패턴

- 작업 순서는 변하지 않지만 각 순서의 구현에 대해서는 변화를 주고 싶은 경우
- 설계를 템플릿 메서드로 하겠다고 결정하고 구현하는 것보다 하면서 발견되는 패턴
- 변하지 않는 기능은 상위 클래스에서 처리, 세부적인 구현이나 자주 변경되는 기능들은 하위 클래스에서 처리

### 장점

- 코드 중복을 줄일 수 있음
- 구현을 각 하위 클래스에 맡기니까 각각의 코드가 분리되어 서로 의존도가 떨어짐

### 단점

- 단계가 많아지면 복잡하다..?

### 적용 예시

- apollo 의 datasource 나 react 의 lifecycle?

## 팩토리 메서드 패턴

- 메서드에서 객체 (인스턴스)를 생성할 때 사용 (팩토리 메서드 패턴보다는 단순한 팩토리 메서드에 대한 정의)
- 책에서는 생성자의 한계인 표현력과 유연함을 극복하기 위함
  - 표현력은 함수명을 통해 다른 인자값에 따라 변하는 객체의 속성을 더 잘 표현할 수 있는 점
  - 유연함은 한 클래스를 통해 다른 클래스를 생성할 수 있다는 점 (`Money.dollar`)
- 팩토리 메서드 패턴 자체는 보통 위 팩토리 메서드를 사용하여 객체가 필요한 시점은 정해져 있는데, 그 객체 생성에 필요한 정보는 알필요 없거나 알 수 없을 때 사용
  - 어찌보면 템플릿 메서드랑 비슷.. 객체를 생성하는 것 자체는 변하지 않으니 상위에서 처리하고, 생성 구현에 대해서는 하위에서 처리

### 장점

- 위에서 나온 생성자의 한계를 극복할 수 있음
- 생성 로직 (하위 클래스에서 처리)와 비즈니스 로직 (상위 클래스에서 처리)이 분리되어 변경에 대응이 잘 됨
  - 의존성이 하위 클래스 -> 상위 (추상) 클래스가 됨
  - 생성에 대한 변경이 생겨도 하위 클래스만 바꾸면 됨

### 단점

- 일단 생성을 구현하는 서브 클래스를 전부 만들어야 하므로 코드가 조금 커질 수 있음.

## 임포스터

- 기존 객체와 인터페이스가 동일하지만 구현은 다른 새로운 객체를 생성하는 기법
- 기존의 객체를 바꿀 수 없거나, 바꾸고 싶지 않을 때 새로운 기능을 테스트해보고 싶으면 사용해볼 수 있는 방법
- 기존의 객체와 인터페이스가 동일한 새로운 객체를 만들어 적용
- 테스트가 아닌 리팩토링을 기준으로 보자면 null 객체 패턴이나 객체의 집합을 단일 객체처럼 취급할 때 사용해 볼 수 있음
  - Money 예제에서 Sum

### 장점

- 테스트시 기존 코드에 변경없이 테스트가 가능함
